name: Automated Rollback System

on:
  workflow_call:
    inputs:
      deployment_id:
        description: 'Deployment ID to monitor'
        required: true
        type: string
      service:
        description: 'Service name'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: string
      current_version:
        description: 'Current deployed version'
        required: true
        type: string
      previous_version:
        description: 'Previous stable version'
        required: true
        type: string
      monitoring_duration:
        description: 'Monitoring duration in seconds'
        required: false
        type: number
        default: 600  # 10 minutes
    secrets:
      MONITORING_TOKEN:
        required: true
      ROLLBACK_TOKEN:
        required: true

env:
  ROLLBACK_TIMEOUT: 180  # 3 minutes
  HEALTH_CHECK_INTERVAL: 30  # 30 seconds
  ERROR_RATE_THRESHOLD: 5  # 5%
  RESPONSE_TIME_THRESHOLD: 2000  # 2 seconds
  AVAILABILITY_THRESHOLD: 95  # 95%

permissions:
  id-token: write
  contents: read
  deployments: write
  actions: write

jobs:
  # Initialize rollback monitoring
  initialize-monitoring:
    name: Initialize Rollback Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    outputs:
      monitoring-config: ${{ steps.config.outputs.config }}
      rollback-thresholds: ${{ steps.thresholds.outputs.thresholds }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure monitoring parameters
        id: config
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          
          # Service-specific monitoring configuration
          case "$SERVICE" in
            "backend")
              ERROR_THRESHOLD=3
              RESPONSE_THRESHOLD=1500
              AVAILABILITY_THRESHOLD=98
              ;;
            "frontend")
              ERROR_THRESHOLD=2
              RESPONSE_THRESHOLD=1000
              AVAILABILITY_THRESHOLD=99
              ;;
            "telegram-bot")
              ERROR_THRESHOLD=1
              RESPONSE_THRESHOLD=500
              AVAILABILITY_THRESHOLD=99.5
              ;;
            "llm-service")
              ERROR_THRESHOLD=5
              RESPONSE_THRESHOLD=5000
              AVAILABILITY_THRESHOLD=95
              ;;
          esac
          
          # Environment-specific adjustments
          case "$ENVIRONMENT" in
            "production")
              # Stricter thresholds for production
              ERROR_THRESHOLD=$((ERROR_THRESHOLD - 1))
              AVAILABILITY_THRESHOLD=$((AVAILABILITY_THRESHOLD + 1))
              ;;
            "development")
              # Relaxed thresholds for development
              ERROR_THRESHOLD=$((ERROR_THRESHOLD + 2))
              AVAILABILITY_THRESHOLD=$((AVAILABILITY_THRESHOLD - 2))
              ;;
          esac
          
          CONFIG=$(cat << EOF
          {
            "service": "$SERVICE",
            "environment": "$ENVIRONMENT",
            "error_threshold": $ERROR_THRESHOLD,
            "response_threshold": $RESPONSE_THRESHOLD,
            "availability_threshold": $AVAILABILITY_THRESHOLD,
            "monitoring_interval": 30,
            "evaluation_window": 300
          }
          EOF
          )
          
          echo "config=$CONFIG" >> $GITHUB_OUTPUT
          echo "üìä Monitoring configuration initialized for $SERVICE ($ENVIRONMENT)"
          
      - name: Set rollback thresholds
        id: thresholds
        run: |
          THRESHOLDS=$(cat << EOF
          {
            "consecutive_failures": 3,
            "error_rate_duration": 300,
            "response_time_duration": 180,
            "availability_duration": 120,
            "health_check_failures": 5,
            "twikit_session_failures": 2
          }
          EOF
          )
          
          echo "thresholds=$THRESHOLDS" >> $GITHUB_OUTPUT
          echo "üéØ Rollback thresholds configured"
          
      - name: Create monitoring record
        run: |
          DEPLOYMENT_ID="${{ inputs.deployment_id }}"
          
          cat > monitoring-record.json << EOF
          {
            "deployment_id": "$DEPLOYMENT_ID",
            "service": "${{ inputs.service }}",
            "environment": "${{ inputs.environment }}",
            "current_version": "${{ inputs.current_version }}",
            "previous_version": "${{ inputs.previous_version }}",
            "monitoring_started": "$(date -Iseconds)",
            "monitoring_duration": ${{ inputs.monitoring_duration }},
            "status": "monitoring",
            "rollback_triggered": false
          }
          EOF
          
          echo "üìù Monitoring record created for deployment: $DEPLOYMENT_ID"
          
      - name: Upload monitoring artifacts
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-record-${{ inputs.deployment_id }}
          path: monitoring-record.json
          retention-days: 30

  # Continuous deployment monitoring
  monitor-deployment:
    name: Monitor Deployment Health
    runs-on: ubuntu-latest
    needs: [initialize-monitoring]
    timeout-minutes: 20
    
    outputs:
      rollback-required: ${{ steps.evaluation.outputs.rollback-required }}
      rollback-reason: ${{ steps.evaluation.outputs.rollback-reason }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download monitoring record
        uses: actions/download-artifact@v4
        with:
          name: monitoring-record-${{ inputs.deployment_id }}
          
      - name: Setup monitoring environment
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          
          # Configure monitoring endpoints
          case "$SERVICE" in
            "backend")
              HEALTH_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3001/health"
              METRICS_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3001/metrics"
              ;;
            "frontend")
              HEALTH_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3000/health"
              METRICS_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3000/metrics"
              ;;
            "telegram-bot")
              HEALTH_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3002/health"
              METRICS_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3002/metrics"
              ;;
            "llm-service")
              HEALTH_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3003/health"
              METRICS_URL="http://${SERVICE}-${ENVIRONMENT}.internal:3003/metrics"
              ;;
          esac
          
          echo "HEALTH_URL=$HEALTH_URL" >> $GITHUB_ENV
          echo "METRICS_URL=$METRICS_URL" >> $GITHUB_ENV
          
          echo "üîç Monitoring endpoints configured"
          echo "  Health: $HEALTH_URL"
          echo "  Metrics: $METRICS_URL"
          
      - name: Continuous health monitoring
        id: monitoring
        run: |
          SERVICE="${{ inputs.service }}"
          MONITORING_DURATION="${{ inputs.monitoring_duration }}"
          
          echo "üè• Starting continuous health monitoring for $MONITORING_DURATION seconds..."
          
          # Initialize monitoring variables
          TOTAL_CHECKS=0
          FAILED_CHECKS=0
          CONSECUTIVE_FAILURES=0
          MAX_CONSECUTIVE_FAILURES=0
          
          ERROR_RATE_VIOLATIONS=0
          RESPONSE_TIME_VIOLATIONS=0
          AVAILABILITY_VIOLATIONS=0
          
          START_TIME=$(date +%s)
          END_TIME=$((START_TIME + MONITORING_DURATION))
          
          # Create monitoring log
          echo "timestamp,health_status,response_time,error_rate,availability" > monitoring-log.csv
          
          while [ $(date +%s) -lt $END_TIME ]; do
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
            REMAINING_TIME=$((END_TIME - CURRENT_TIME))
            
            echo "‚è±Ô∏è Monitoring progress: ${ELAPSED_TIME}s elapsed, ${REMAINING_TIME}s remaining"
            
            TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
            
            # Simulate health check
            HEALTH_STATUS="healthy"
            RESPONSE_TIME=$((100 + RANDOM % 200))  # 100-300ms
            ERROR_RATE=$((RANDOM % 10))  # 0-9%
            AVAILABILITY=$((95 + RANDOM % 5))  # 95-99%
            
            # Simulate occasional issues for testing
            if [ $((RANDOM % 20)) -eq 0 ]; then
              HEALTH_STATUS="unhealthy"
              RESPONSE_TIME=$((2000 + RANDOM % 1000))  # 2-3s
              ERROR_RATE=$((5 + RANDOM % 10))  # 5-15%
              AVAILABILITY=$((85 + RANDOM % 10))  # 85-95%
            fi
            
            # Log monitoring data
            echo "$(date -Iseconds),$HEALTH_STATUS,$RESPONSE_TIME,$ERROR_RATE,$AVAILABILITY" >> monitoring-log.csv
            
            # Evaluate health status
            if [ "$HEALTH_STATUS" = "unhealthy" ]; then
              FAILED_CHECKS=$((FAILED_CHECKS + 1))
              CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
              
              if [ $CONSECUTIVE_FAILURES -gt $MAX_CONSECUTIVE_FAILURES ]; then
                MAX_CONSECUTIVE_FAILURES=$CONSECUTIVE_FAILURES
              fi
            else
              CONSECUTIVE_FAILURES=0
            fi
            
            # Check thresholds
            CONFIG='${{ needs.initialize-monitoring.outputs.monitoring-config }}'
            ERROR_THRESHOLD=$(echo "$CONFIG" | jq -r '.error_threshold')
            RESPONSE_THRESHOLD=$(echo "$CONFIG" | jq -r '.response_threshold')
            AVAILABILITY_THRESHOLD=$(echo "$CONFIG" | jq -r '.availability_threshold')
            
            if [ $ERROR_RATE -gt $ERROR_THRESHOLD ]; then
              ERROR_RATE_VIOLATIONS=$((ERROR_RATE_VIOLATIONS + 1))
            fi
            
            if [ $RESPONSE_TIME -gt $RESPONSE_THRESHOLD ]; then
              RESPONSE_TIME_VIOLATIONS=$((RESPONSE_TIME_VIOLATIONS + 1))
            fi
            
            if [ $AVAILABILITY -lt $AVAILABILITY_THRESHOLD ]; then
              AVAILABILITY_VIOLATIONS=$((AVAILABILITY_VIOLATIONS + 1))
            fi
            
            echo "üìä Current metrics: Health=$HEALTH_STATUS, RT=${RESPONSE_TIME}ms, ER=${ERROR_RATE}%, Avail=${AVAILABILITY}%"
            echo "üî¢ Violations: Consecutive failures=$CONSECUTIVE_FAILURES, Error rate=$ERROR_RATE_VIOLATIONS, Response time=$RESPONSE_TIME_VIOLATIONS, Availability=$AVAILABILITY_VIOLATIONS"
            
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done
          
          # Calculate final statistics
          if [ $TOTAL_CHECKS -gt 0 ]; then
            FAILURE_RATE=$((FAILED_CHECKS * 100 / TOTAL_CHECKS))
          else
            FAILURE_RATE=0
          fi
          
          echo "üìà Final monitoring statistics:"
          echo "  Total checks: $TOTAL_CHECKS"
          echo "  Failed checks: $FAILED_CHECKS"
          echo "  Failure rate: ${FAILURE_RATE}%"
          echo "  Max consecutive failures: $MAX_CONSECUTIVE_FAILURES"
          echo "  Error rate violations: $ERROR_RATE_VIOLATIONS"
          echo "  Response time violations: $RESPONSE_TIME_VIOLATIONS"
          echo "  Availability violations: $AVAILABILITY_VIOLATIONS"
          
          # Export statistics for evaluation
          echo "total-checks=$TOTAL_CHECKS" >> $GITHUB_OUTPUT
          echo "failed-checks=$FAILED_CHECKS" >> $GITHUB_OUTPUT
          echo "failure-rate=$FAILURE_RATE" >> $GITHUB_OUTPUT
          echo "max-consecutive-failures=$MAX_CONSECUTIVE_FAILURES" >> $GITHUB_OUTPUT
          echo "error-rate-violations=$ERROR_RATE_VIOLATIONS" >> $GITHUB_OUTPUT
          echo "response-time-violations=$RESPONSE_TIME_VIOLATIONS" >> $GITHUB_OUTPUT
          echo "availability-violations=$AVAILABILITY_VIOLATIONS" >> $GITHUB_OUTPUT
          
      - name: Twikit-specific monitoring
        if: inputs.service == 'llm-service'
        run: |
          echo "üê¶ Performing Twikit-specific health checks..."
          
          # Simulate Twikit session monitoring
          TWIKIT_SESSION_FAILURES=0
          TWIKIT_RATE_LIMIT_VIOLATIONS=0
          TWIKIT_PROXY_FAILURES=0
          
          for i in {1..5}; do
            echo "üîç Twikit check $i/5..."
            
            # Simulate session check
            if [ $((RANDOM % 10)) -lt 9 ]; then
              echo "  ‚úÖ Session management: OK"
            else
              echo "  ‚ùå Session management: FAILED"
              TWIKIT_SESSION_FAILURES=$((TWIKIT_SESSION_FAILURES + 1))
            fi
            
            # Simulate rate limit check
            if [ $((RANDOM % 10)) -lt 8 ]; then
              echo "  ‚úÖ Rate limiting: OK"
            else
              echo "  ‚ùå Rate limiting: VIOLATED"
              TWIKIT_RATE_LIMIT_VIOLATIONS=$((TWIKIT_RATE_LIMIT_VIOLATIONS + 1))
            fi
            
            # Simulate proxy check
            if [ $((RANDOM % 10)) -lt 9 ]; then
              echo "  ‚úÖ Proxy rotation: OK"
            else
              echo "  ‚ùå Proxy rotation: FAILED"
              TWIKIT_PROXY_FAILURES=$((TWIKIT_PROXY_FAILURES + 1))
            fi
            
            sleep 10
          done
          
          echo "üê¶ Twikit monitoring results:"
          echo "  Session failures: $TWIKIT_SESSION_FAILURES"
          echo "  Rate limit violations: $TWIKIT_RATE_LIMIT_VIOLATIONS"
          echo "  Proxy failures: $TWIKIT_PROXY_FAILURES"
          
          # Export Twikit statistics
          echo "twikit-session-failures=$TWIKIT_SESSION_FAILURES" >> $GITHUB_OUTPUT
          echo "twikit-rate-limit-violations=$TWIKIT_RATE_LIMIT_VIOLATIONS" >> $GITHUB_OUTPUT
          echo "twikit-proxy-failures=$TWIKIT_PROXY_FAILURES" >> $GITHUB_OUTPUT
          
      - name: Evaluate rollback criteria
        id: evaluation
        run: |
          echo "üîç Evaluating rollback criteria..."
          
          # Get monitoring statistics
          FAILURE_RATE="${{ steps.monitoring.outputs.failure-rate }}"
          MAX_CONSECUTIVE_FAILURES="${{ steps.monitoring.outputs.max-consecutive-failures }}"
          ERROR_RATE_VIOLATIONS="${{ steps.monitoring.outputs.error-rate-violations }}"
          RESPONSE_TIME_VIOLATIONS="${{ steps.monitoring.outputs.response-time-violations }}"
          AVAILABILITY_VIOLATIONS="${{ steps.monitoring.outputs.availability-violations }}"
          
          # Get rollback thresholds
          THRESHOLDS='${{ needs.initialize-monitoring.outputs.rollback-thresholds }}'
          CONSECUTIVE_THRESHOLD=$(echo "$THRESHOLDS" | jq -r '.consecutive_failures')
          
          ROLLBACK_REQUIRED=false
          ROLLBACK_REASONS=()
          
          # Check consecutive failures
          if [ $MAX_CONSECUTIVE_FAILURES -ge $CONSECUTIVE_THRESHOLD ]; then
            ROLLBACK_REQUIRED=true
            ROLLBACK_REASONS+=("Consecutive health check failures: $MAX_CONSECUTIVE_FAILURES >= $CONSECUTIVE_THRESHOLD")
          fi
          
          # Check error rate violations
          if [ $ERROR_RATE_VIOLATIONS -ge 5 ]; then
            ROLLBACK_REQUIRED=true
            ROLLBACK_REASONS+=("Error rate violations: $ERROR_RATE_VIOLATIONS")
          fi
          
          # Check response time violations
          if [ $RESPONSE_TIME_VIOLATIONS -ge 5 ]; then
            ROLLBACK_REQUIRED=true
            ROLLBACK_REASONS+=("Response time violations: $RESPONSE_TIME_VIOLATIONS")
          fi
          
          # Check availability violations
          if [ $AVAILABILITY_VIOLATIONS -ge 3 ]; then
            ROLLBACK_REQUIRED=true
            ROLLBACK_REASONS+=("Availability violations: $AVAILABILITY_VIOLATIONS")
          fi
          
          # Check overall failure rate
          if [ $FAILURE_RATE -ge 20 ]; then
            ROLLBACK_REQUIRED=true
            ROLLBACK_REASONS+=("High failure rate: ${FAILURE_RATE}%")
          fi
          
          # Twikit-specific checks
          if [ "${{ inputs.service }}" = "llm-service" ]; then
            TWIKIT_SESSION_FAILURES="${{ steps.monitoring.outputs.twikit-session-failures }}"
            if [ $TWIKIT_SESSION_FAILURES -ge 2 ]; then
              ROLLBACK_REQUIRED=true
              ROLLBACK_REASONS+=("Twikit session failures: $TWIKIT_SESSION_FAILURES")
            fi
          fi
          
          # Format rollback reason
          if [ "$ROLLBACK_REQUIRED" = true ]; then
            ROLLBACK_REASON=$(IFS='; '; echo "${ROLLBACK_REASONS[*]}")
          else
            ROLLBACK_REASON="No rollback criteria met"
          fi
          
          echo "rollback-required=$ROLLBACK_REQUIRED" >> $GITHUB_OUTPUT
          echo "rollback-reason=$ROLLBACK_REASON" >> $GITHUB_OUTPUT
          
          if [ "$ROLLBACK_REQUIRED" = true ]; then
            error "üö® ROLLBACK REQUIRED: $ROLLBACK_REASON"
          else
            success "‚úÖ Deployment monitoring completed successfully - no rollback required"
          fi
          
      - name: Upload monitoring results
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-results-${{ inputs.deployment_id }}
          path: |
            monitoring-log.csv
            monitoring-record.json
          retention-days: 30

  # Execute automated rollback
  execute-rollback:
    name: Execute Automated Rollback
    runs-on: ubuntu-latest
    needs: [initialize-monitoring, monitor-deployment]
    if: needs.monitor-deployment.outputs.rollback-required == 'true'
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download monitoring artifacts
        uses: actions/download-artifact@v4
        with:
          name: monitoring-results-${{ inputs.deployment_id }}
          
      - name: Initiate rollback procedure
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          CURRENT_VERSION="${{ inputs.current_version }}"
          PREVIOUS_VERSION="${{ inputs.previous_version }}"
          ROLLBACK_REASON="${{ needs.monitor-deployment.outputs.rollback-reason }}"
          
          echo "üö® INITIATING AUTOMATED ROLLBACK"
          echo "Service: $SERVICE"
          echo "Environment: $ENVIRONMENT"
          echo "Current version: $CURRENT_VERSION"
          echo "Rolling back to: $PREVIOUS_VERSION"
          echo "Reason: $ROLLBACK_REASON"
          
          # Create rollback record
          cat > rollback-record.json << EOF
          {
            "deployment_id": "${{ inputs.deployment_id }}",
            "service": "$SERVICE",
            "environment": "$ENVIRONMENT",
            "rollback_initiated": "$(date -Iseconds)",
            "current_version": "$CURRENT_VERSION",
            "target_version": "$PREVIOUS_VERSION",
            "rollback_reason": "$ROLLBACK_REASON",
            "rollback_type": "automated",
            "status": "in_progress"
          }
          EOF
          
          echo "üìù Rollback record created"
          
      - name: Stop current deployment
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          
          echo "üõë Stopping current deployment..."
          
          # Simulate stopping current deployment
          echo "  Draining traffic from current version..."
          sleep 5
          
          echo "  Stopping application instances..."
          sleep 5
          
          echo "‚úÖ Current deployment stopped"
          
      - name: Deploy previous version
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          PREVIOUS_VERSION="${{ inputs.previous_version }}"
          
          echo "üîÑ Deploying previous version: $PREVIOUS_VERSION"
          
          # Simulate deployment of previous version
          echo "  Pulling previous image: $PREVIOUS_VERSION"
          sleep 5
          
          echo "  Starting application instances..."
          sleep 10
          
          echo "  Configuring load balancer..."
          sleep 5
          
          echo "‚úÖ Previous version deployed"
          
      - name: Validate rollback success
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          
          echo "üîç Validating rollback success..."
          
          # Health check validation
          MAX_ATTEMPTS=10
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Simulate health check
            if [ $((RANDOM % 10)) -lt 8 ]; then
              echo "‚úÖ Health check passed"
              break
            else
              echo "‚ö†Ô∏è Health check failed, retrying..."
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "‚ùå Rollback validation failed"
            exit 1
          fi
          
          # Performance validation
          echo "üìä Validating performance metrics..."
          sleep 10
          
          echo "‚úÖ Rollback validation completed successfully"
          
      - name: Update rollback record
        run: |
          # Update rollback record with success status
          jq '.status = "completed" | .completed_at = "'$(date -Iseconds)'"' rollback-record.json > rollback-record-updated.json
          mv rollback-record-updated.json rollback-record.json
          
          echo "üìù Rollback record updated with success status"
          
      - name: Send rollback notification
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          ROLLBACK_REASON="${{ needs.monitor-deployment.outputs.rollback-reason }}"
          
          echo "üì¢ Sending rollback notification..."
          
          # In a real implementation, this would send notifications via:
          # - Slack webhook
          # - Email alerts
          # - PagerDuty incident
          # - GitHub issue creation
          
          cat << EOF
          üö® AUTOMATED ROLLBACK EXECUTED
          
          Service: $SERVICE
          Environment: $ENVIRONMENT
          Deployment ID: ${{ inputs.deployment_id }}
          Rollback Reason: $ROLLBACK_REASON
          Rollback Completed: $(date -Iseconds)
          
          The deployment has been automatically rolled back due to health check failures.
          Please investigate the issues before attempting another deployment.
          EOF
          
          echo "‚úÖ Rollback notification sent"
          
      - name: Upload rollback artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rollback-record-${{ inputs.deployment_id }}
          path: rollback-record.json
          retention-days: 90

  # Deployment success confirmation
  confirm-deployment-success:
    name: Confirm Deployment Success
    runs-on: ubuntu-latest
    needs: [initialize-monitoring, monitor-deployment]
    if: needs.monitor-deployment.outputs.rollback-required == 'false'
    timeout-minutes: 5
    
    steps:
      - name: Mark deployment as successful
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          CURRENT_VERSION="${{ inputs.current_version }}"
          
          echo "‚úÖ DEPLOYMENT SUCCESSFUL"
          echo "Service: $SERVICE"
          echo "Environment: $ENVIRONMENT"
          echo "Version: $CURRENT_VERSION"
          echo "Monitoring completed without issues"
          
          # Create success record
          cat > deployment-success.json << EOF
          {
            "deployment_id": "${{ inputs.deployment_id }}",
            "service": "$SERVICE",
            "environment": "$ENVIRONMENT",
            "version": "$CURRENT_VERSION",
            "status": "successful",
            "confirmed_at": "$(date -Iseconds)",
            "monitoring_duration": ${{ inputs.monitoring_duration }}
          }
          EOF
          
          echo "üìù Deployment success record created"
          
      - name: Send success notification
        run: |
          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"
          
          echo "üì¢ Sending deployment success notification..."
          
          cat << EOF
          ‚úÖ DEPLOYMENT SUCCESSFUL
          
          Service: $SERVICE
          Environment: $ENVIRONMENT
          Deployment ID: ${{ inputs.deployment_id }}
          Version: ${{ inputs.current_version }}
          Monitoring Duration: ${{ inputs.monitoring_duration }} seconds
          
          The deployment has been successfully validated and is now stable.
          EOF
          
          echo "‚úÖ Success notification sent"
          
      - name: Upload success artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-success-${{ inputs.deployment_id }}
          path: deployment-success.json
          retention-days: 30
